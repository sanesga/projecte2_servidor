/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { INITIAL_STATE_TOKEN } from '@ngxs/store/internals';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _initialState
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    static checkStatesAreValid(stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        StateFactory.checkStatesAreValid(stateClasses);
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const depth = depths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, depth);
            /** @type {?} */
            const stateMap = {
                name,
                depth,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, depth)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const mappedStores = this.add(classes);
        /** @type {?} */
        const defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        (result, mappedStore) => setValue(result, mappedStore.depth, mappedStore.defaults)), {});
        return { defaults, states: mappedStores };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ action }) => this.invokeActions(this._actions, (/** @type {?} */ (action))).pipe(map((/**
         * @return {?}
         */
        () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
        this._connected = true;
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} depth
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, depth) {
        meta.path = depth;
        meta.selectFromAppState = propGetter(depth.split('.'), this._config);
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLGtCQUFrQixFQUNsQixRQUFRLEVBR1IsV0FBVyxFQUNYLFVBQVUsRUFLVixlQUFlLEVBQ2hCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUErQixlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLG1CQUFtQixFQUFpQixNQUFNLHVCQUF1QixDQUFDOzs7OztBQU8zRSxNQUFN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LElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDM0IsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUNuQztTQUNGO1FBRUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7Ozs7Ozs7SUFFTyxvQkFBb0IsQ0FBQyxJQUFtQixFQUFFLEtBQWE7UUFDN0QsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2RSxDQUFDOzs7Ozs7Ozs7O0lBU08sNkJBQTZCLENBQUMsSUFBWSxFQUFFLElBQVk7O2NBQ3hELGlDQUFpQyxHQUNyQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxTQUFTO1FBQ2xELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxpQ0FBaUMsQ0FBQztJQUN0RSxDQUFDOzs7WUFsTkYsVUFBVTs7OztZQXZDVSxRQUFRO1lBWVYsVUFBVTtZQW9DRCxZQUFZLHVCQUZuQyxRQUFRLFlBQ1IsUUFBUTtZQWxCeUIsZUFBZTtZQUM1QywrQkFBK0I7WUFDL0IsbUJBQW1COzRDQXFCdkIsUUFBUSxZQUNSLE1BQU0sU0FBQyxtQkFBbUI7Ozs7Ozs7SUFaN0Isa0NBQTJCOzs7OztJQWdCM0IsK0JBQW9DOzs7OztJQU1wQyxxQ0FBeUM7Ozs7O0lBbkJ2QyxpQ0FBMkI7Ozs7O0lBQzNCLCtCQUEyQjs7Ozs7SUFDM0Isc0NBRW9DOzs7OztJQUNwQyxnQ0FBaUM7Ozs7O0lBQ2pDLHNDQUF1RDs7Ozs7SUFDdkQsNENBQWlEOzs7OztJQUNqRCxxQ0FFMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgZm9ya0pvaW4sIGZyb20sIE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7XHJcbiAgY2F0Y2hFcnJvcixcclxuICBkZWZhdWx0SWZFbXB0eSxcclxuICBmaWx0ZXIsXHJcbiAgbWFwLFxyXG4gIG1lcmdlTWFwLFxyXG4gIHNoYXJlUmVwbGF5LFxyXG4gIHRha2VVbnRpbFxyXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7XHJcbiAgYnVpbGRHcmFwaCxcclxuICBmaW5kRnVsbFBhcmVudFBhdGgsXHJcbiAgaXNPYmplY3QsXHJcbiAgTWFwcGVkU3RvcmUsXHJcbiAgTWV0YURhdGFNb2RlbCxcclxuICBuYW1lVG9TdGF0ZSxcclxuICBwcm9wR2V0dGVyLFxyXG4gIFN0YXRlQ2xhc3NJbnRlcm5hbCxcclxuICBTdGF0ZUtleUdyYXBoLFxyXG4gIFN0YXRlc0FuZERlZmF1bHRzLFxyXG4gIFN0YXRlc0J5TmFtZSxcclxuICB0b3BvbG9naWNhbFNvcnRcclxufSBmcm9tICcuL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XHJcbmltcG9ydCB7IEFjdGlvbkNvbnRleHQsIEFjdGlvblN0YXR1cywgSW50ZXJuYWxBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5pbXBvcnQgeyBTdG9yZVZhbGlkYXRvcnMgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcclxuaW1wb3J0IHsgSU5JVElBTF9TVEFURV9UT0tFTiwgUGxhaW5PYmplY3RPZiB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XHJcblxyXG4vKipcclxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3Rvcnkge1xyXG4gIHByaXZhdGUgX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQEluamVjdChJTklUSUFMX1NUQVRFX1RPS0VOKVxyXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFN0YXRlOiBhbnlcclxuICApIHt9XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG5cclxuICBwdWJsaWMgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdGF0ZXNCeU5hbWU6IFN0YXRlc0J5TmFtZSA9IHt9O1xyXG5cclxuICBwdWJsaWMgZ2V0IHN0YXRlc0J5TmFtZSgpOiBTdGF0ZXNCeU5hbWUge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlc0J5TmFtZSA6IHRoaXMuX3N0YXRlc0J5TmFtZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVmYXVsdHMoZGVmYXVsdHM6IGFueSk6IGFueSB7XHJcbiAgICBsZXQgdmFsdWUgPSB7fTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcclxuICAgICAgdmFsdWUgPSBkZWZhdWx0cy5zbGljZSgpO1xyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcclxuICAgICAgdmFsdWUgPSB7IC4uLmRlZmF1bHRzIH07XHJcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFsdWUgPSB7fTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gZGVmYXVsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY2hlY2tTdGF0ZXNBcmVWYWxpZChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogdm9pZCB7XHJcbiAgICBzdGF0ZUNsYXNzZXMuZm9yRWFjaChTdG9yZVZhbGlkYXRvcnMuZ2V0VmFsaWRTdGF0ZU1ldGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgU3RhdGVGYWN0b3J5LmNoZWNrU3RhdGVzQXJlVmFsaWQoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IGRlcHRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoOiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4gPSBuYW1lVG9TdGF0ZShuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwgPSBuYW1lR3JhcGhbbmFtZV07XHJcbiAgICAgIGNvbnN0IGRlcHRoOiBzdHJpbmcgPSBkZXB0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IG1ldGE6IE1ldGFEYXRhTW9kZWwgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XHJcblxyXG4gICAgICB0aGlzLmFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGEsIGRlcHRoKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlTWFwOiBNYXBwZWRTdG9yZSA9IHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGRlcHRoLFxyXG4gICAgICAgIGlzSW5pdGlhbGlzZWQ6IGZhbHNlLFxyXG4gICAgICAgIGFjdGlvbnM6IG1ldGEuYWN0aW9ucyxcclxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxyXG4gICAgICAgIGRlZmF1bHRzOiBTdGF0ZUZhY3RvcnkuY2xvbmVEZWZhdWx0cyhtZXRhLmRlZmF1bHRzKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgIC8vIGJ1dCBkb24ndCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XHJcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xyXG4gICAgICBpZiAoIXRoaXMuaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZSwgZGVwdGgpKSB7XHJcbiAgICAgICAgYm9vdHN0cmFwcGVkU3RvcmVzLnB1c2goc3RhdGVNYXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm9vdHN0cmFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsdHNcclxuICAgKi9cclxuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVzQW5kRGVmYXVsdHMge1xyXG4gICAgY29uc3QgY2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XHJcblxyXG4gICAgY29uc3QgbWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gdGhpcy5hZGQoY2xhc3Nlcyk7XHJcbiAgICBjb25zdCBkZWZhdWx0cyA9IG1hcHBlZFN0b3Jlcy5yZWR1Y2UoXHJcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxyXG4gICAgICAgIHNldFZhbHVlKHJlc3VsdCwgbWFwcGVkU3RvcmUuZGVwdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcclxuICAgICAge31cclxuICAgICk7XHJcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgdGhlIGFjdGlvbnMgdG8gdGhlIGhhbmRsZXJzXHJcbiAgICovXHJcbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy5fYWN0aW9uc1xyXG4gICAgICAucGlwZShcclxuICAgICAgICBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LnN0YXR1cyA9PT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICAgIG1lcmdlTWFwKCh7IGFjdGlvbiB9KSA9PlxyXG4gICAgICAgICAgdGhpcy5pbnZva2VBY3Rpb25zKHRoaXMuX2FjdGlvbnMsIGFjdGlvbiEpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxyXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+XHJcbiAgICAgICAgICAgICAgb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xyXG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlQWN0aW9ucyhhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBhY3Rpb246IGFueSkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKSE7XHJcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChhY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoXHJcbiAgICBzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdXHJcbiAgKTogeyBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdIH0ge1xyXG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IFtdO1xyXG4gICAgY29uc3Qgc3RhdGVzTWFwOiBTdGF0ZXNCeU5hbWUgPSB0aGlzLnN0YXRlc0J5TmFtZTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlTmFtZTogc3RyaW5nID0gU3RvcmVWYWxpZGF0b3JzLmNoZWNrU3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcclxuICAgICAgY29uc3QgdW5tb3VudGVkU3RhdGUgPSAhc3RhdGVzTWFwW3N0YXRlTmFtZV07XHJcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xyXG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xyXG4gICAgICAgIHN0YXRlc01hcFtzdGF0ZU5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiBNZXRhRGF0YU1vZGVsLCBkZXB0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBtZXRhLnBhdGggPSBkZXB0aDtcclxuICAgIG1ldGEuc2VsZWN0RnJvbUFwcFN0YXRlID0gcHJvcEdldHRlcihkZXB0aC5zcGxpdCgnLicpLCB0aGlzLl9jb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogdGhlIG1ldGhvZCBjaGVja3MgaWYgdGhlIHN0YXRlIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIHRyZWVcclxuICAgKiBhbmQgY29tcGxldGVkIHRoZSBsaWZlIGN5Y2xlXHJcbiAgICogQHBhcmFtIG5hbWVcclxuICAgKiBAcGFyYW0gcGF0aFxyXG4gICAqL1xyXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHZhbHVlSXNCb290c3RyYXBwZWRJbkluaXRpYWxTdGF0ZTogYm9vbGVhbiA9XHJcbiAgICAgIGdldFZhbHVlKHRoaXMuX2luaXRpYWxTdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlc0J5TmFtZVtuYW1lXSAmJiB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU7XHJcbiAgfVxyXG59XHJcbiJdfQ==