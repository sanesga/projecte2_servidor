/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { memoize } from '@ngxs/store/internals';
import { ensureSelectorMetadata, getSelectorMetadata, getStoreMetadata, globalSelectorOptions } from '../internal/internals';
/** @type {?} */
const SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';
/** @type {?} */
export const selectorOptionsMetaAccessor = {
    getOptions: (/**
     * @param {?} target
     * @return {?}
     */
    (target) => {
        return (target && ((/** @type {?} */ (target)))[SELECTOR_OPTIONS_META_KEY]) || {};
    }),
    defineOptions: (/**
     * @param {?} target
     * @param {?} options
     * @return {?}
     */
    (target, options) => {
        if (!target)
            return;
        ((/** @type {?} */ (target)))[SELECTOR_OPTIONS_META_KEY] = options;
    })
};
/**
 * @record
 */
function CreationMetadata() { }
if (false) {
    /** @type {?} */
    CreationMetadata.prototype.containerClass;
    /** @type {?} */
    CreationMetadata.prototype.selectorName;
    /** @type {?|undefined} */
    CreationMetadata.prototype.getSelectorOptions;
}
/**
 * @record
 */
function RuntimeSelectorInfo() { }
if (false) {
    /** @type {?} */
    RuntimeSelectorInfo.prototype.selectorOptions;
    /** @type {?} */
    RuntimeSelectorInfo.prototype.argumentSelectorFunctions;
}
/**
 * Function for creating a selector
 * @template T
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
export function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const wrappedFn = (/** @type {?} */ ((/**
     * @param {...?} args
     * @return {?}
     */
    function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn.apply(containerClass, args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    })));
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const selectorMetaData = setupSelectorMetadata(memoizedFn, originalFn, creationMetadata);
    /** @type {?} */
    let runtimeInfo;
    /** @type {?} */
    const selectFromAppState = (/**
     * @param {?} state
     * @return {?}
     */
    (state) => {
        /** @type {?} */
        const results = [];
        runtimeInfo = runtimeInfo || getRuntimeSelectorInfo(selectorMetaData, selectors);
        const { suppressErrors } = runtimeInfo.selectorOptions;
        const { argumentSelectorFunctions } = runtimeInfo;
        // Determine arguments from the app state using the selectors
        results.push(...argumentSelectorFunctions.map((/**
         * @param {?} argFn
         * @return {?}
         */
        argFn => argFn(state))));
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError && suppressErrors) {
                return undefined;
            }
            throw ex;
        }
    });
    selectorMetaData.selectFromAppState = selectFromAppState;
    return memoizedFn;
}
/**
 * @template T
 * @param {?} memoizedFn
 * @param {?} originalFn
 * @param {?} creationMetadata
 * @return {?}
 */
function setupSelectorMetadata(memoizedFn, originalFn, creationMetadata) {
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    /** @type {?} */
    let getExplicitSelectorOptions = (/**
     * @return {?}
     */
    () => ({}));
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
        getExplicitSelectorOptions =
            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;
    }
    /** @type {?} */
    const selectorMetaDataClone = Object.assign({}, selectorMetaData);
    selectorMetaData.getSelectorOptions = (/**
     * @return {?}
     */
    () => getCustomSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions()));
    return selectorMetaData;
}
/**
 * @param {?} selectorMetaData
 * @param {?=} selectors
 * @return {?}
 */
function getRuntimeSelectorInfo(selectorMetaData, selectors = []) {
    /** @type {?} */
    const selectorOptions = selectorMetaData.getSelectorOptions();
    /** @type {?} */
    const selectorsToApply = getSelectorsToApply(selectorMetaData, selectors);
    /** @type {?} */
    const argumentSelectorFunctions = selectorsToApply.map((/**
     * @param {?} selector
     * @return {?}
     */
    selector => getSelectorFn(selector)));
    return {
        selectorOptions,
        argumentSelectorFunctions
    };
}
/**
 * @param {?} selectorMetaData
 * @param {?} explicitOptions
 * @return {?}
 */
function getCustomSelectorOptions(selectorMetaData, explicitOptions) {
    /** @type {?} */
    const selectorOptions = Object.assign({}, globalSelectorOptions.get(), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), (selectorMetaData.getSelectorOptions() || {}), explicitOptions);
    return selectorOptions;
}
/**
 * @param {?} selectorMetaData
 * @param {?=} selectors
 * @return {?}
 */
function getSelectorsToApply(selectorMetaData, selectors = []) {
    /** @type {?} */
    const selectorsToApply = [];
    /** @type {?} */
    const canInjectContainerState = selectors.length === 0 || selectorMetaData.getSelectorOptions().injectContainerState;
    /** @type {?} */
    const containerClass = selectorMetaData.containerClass;
    if (containerClass && canInjectContainerState) {
        // If we are on a state class, add it as the first selector parameter
        /** @type {?} */
        const metadata = getStoreMetadata(containerClass);
        if (metadata) {
            selectorsToApply.push(containerClass);
        }
    }
    if (selectors) {
        selectorsToApply.push(...selectors);
    }
    return selectorsToApply;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
export function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy9zZWxlY3Rvci11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRWhELE9BQU8sRUFDTCxzQkFBc0IsRUFDdEIsbUJBQW1CLEVBQ25CLGdCQUFnQixFQUNoQixxQkFBcUIsRUFJdEIsTUFBTSx1QkFBdUIsQ0FBQzs7TUFFekIseUJBQXlCLEdBQUcsNEJBQTRCOztBQUU5RCxNQUFNLE9BQU8sMkJBQTJCLEdBQUc7SUFDekMsVUFBVTs7OztJQUFFLENBQUMsTUFBVyxFQUF5QixFQUFFO1FBQ2pELE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxtQkFBSyxNQUFNLEVBQUEsQ0FBQyxDQUFDLHlCQUF5QixDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDcEUsQ0FBQyxDQUFBO0lBQ0QsYUFBYTs7Ozs7SUFBRSxDQUFDLE1BQVcsRUFBRSxPQUE4QixFQUFFLEVBQUU7UUFDN0QsSUFBSSxDQUFDLE1BQU07WUFBRSxPQUFPO1FBQ3BCLENBQUMsbUJBQUssTUFBTSxFQUFBLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUNyRCxDQUFDLENBQUE7Q0FDRjs7OztBQUVELCtCQUlDOzs7SUFIQywwQ0FBb0I7O0lBQ3BCLHdDQUFxQjs7SUFDckIsOENBQWlEOzs7OztBQUduRCxrQ0FHQzs7O0lBRkMsOENBQXVDOztJQUN2Qyx3REFBbUQ7Ozs7Ozs7Ozs7QUFTckQsTUFBTSxVQUFVLGNBQWMsQ0FDNUIsU0FBNEIsRUFDNUIsVUFBYSxFQUNiLGdCQUFtQzs7VUFFN0IsY0FBYyxHQUFHLGdCQUFnQixJQUFJLGdCQUFnQixDQUFDLGNBQWM7O1VBQ3BFLFNBQVMsR0FBRzs7OztJQUFBLFNBQVMsaUJBQWlCLENBQUMsR0FBRyxJQUFXOztj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QixDQUFDLElBQUksUUFBUSxDQUFDO0FBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSxcclxuICBnZXRTZWxlY3Rvck1ldGFkYXRhLFxyXG4gIGdldFN0b3JlTWV0YWRhdGEsXHJcbiAgZ2xvYmFsU2VsZWN0b3JPcHRpb25zLFxyXG4gIFNlbGVjdEZyb21TdGF0ZSxcclxuICBTZWxlY3Rvck1ldGFEYXRhTW9kZWwsXHJcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zXHJcbn0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuXHJcbmNvbnN0IFNFTEVDVE9SX09QVElPTlNfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9PUFRJT05TX01FVEEnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNlbGVjdG9yT3B0aW9uc01ldGFBY2Nlc3NvciA9IHtcclxuICBnZXRPcHRpb25zOiAodGFyZ2V0OiBhbnkpOiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMgPT4ge1xyXG4gICAgcmV0dXJuICh0YXJnZXQgJiYgKDxhbnk+dGFyZ2V0KVtTRUxFQ1RPUl9PUFRJT05TX01FVEFfS0VZXSkgfHwge307XHJcbiAgfSxcclxuICBkZWZpbmVPcHRpb25zOiAodGFyZ2V0OiBhbnksIG9wdGlvbnM6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybjtcclxuICAgICg8YW55PnRhcmdldClbU0VMRUNUT1JfT1BUSU9OU19NRVRBX0tFWV0gPSBvcHRpb25zO1xyXG4gIH1cclxufTtcclxuXHJcbmludGVyZmFjZSBDcmVhdGlvbk1ldGFkYXRhIHtcclxuICBjb250YWluZXJDbGFzczogYW55O1xyXG4gIHNlbGVjdG9yTmFtZTogc3RyaW5nO1xyXG4gIGdldFNlbGVjdG9yT3B0aW9ucz86ICgpID0+IFNoYXJlZFNlbGVjdG9yT3B0aW9ucztcclxufVxyXG5cclxuaW50ZXJmYWNlIFJ1bnRpbWVTZWxlY3RvckluZm8ge1xyXG4gIHNlbGVjdG9yT3B0aW9uczogU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xyXG4gIGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnM6ICgoc3RhdGU6IGFueSkgPT4gYW55KVtdO1xyXG59XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgc2VsZWN0b3JcclxuICogQHBhcmFtIHNlbGVjdG9ycyBUaGUgc2VsZWN0b3JzIHRvIHVzZSB0byBjcmVhdGUgdGhlIGFyZ3VtZW50cyBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWluZyBtYWRlIGludG8gYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gY3JlYXRpb25NZXRhZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXHJcbiAgc2VsZWN0b3JzOiBhbnlbXSB8IHVuZGVmaW5lZCxcclxuICBvcmlnaW5hbEZuOiBULFxyXG4gIGNyZWF0aW9uTWV0YWRhdGE/OiBDcmVhdGlvbk1ldGFkYXRhXHJcbikge1xyXG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xyXG4gIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRTZWxlY3RvckZuKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4uYXBwbHkoY29udGFpbmVyQ2xhc3MsIGFyZ3MpO1xyXG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgY29uc3QgaW5uZXJNZW1vaXplZEZuID0gbWVtb2l6ZS5hcHBseShudWxsLCBbcmV0dXJuVmFsdWVdKTtcclxuICAgICAgcmV0dXJuIGlubmVyTWVtb2l6ZWRGbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICB9IGFzIFQ7XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBzZWxlY3Rvck1ldGFEYXRhID0gc2V0dXBTZWxlY3Rvck1ldGFkYXRhPFQ+KG1lbW9pemVkRm4sIG9yaWdpbmFsRm4sIGNyZWF0aW9uTWV0YWRhdGEpO1xyXG4gIGxldCBydW50aW1lSW5mbzogUnVudGltZVNlbGVjdG9ySW5mbztcclxuXHJcbiAgY29uc3Qgc2VsZWN0RnJvbUFwcFN0YXRlID0gKHN0YXRlOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBydW50aW1lSW5mbyA9IHJ1bnRpbWVJbmZvIHx8IGdldFJ1bnRpbWVTZWxlY3RvckluZm8oc2VsZWN0b3JNZXRhRGF0YSwgc2VsZWN0b3JzKTtcclxuICAgIGNvbnN0IHsgc3VwcHJlc3NFcnJvcnMgfSA9IHJ1bnRpbWVJbmZvLnNlbGVjdG9yT3B0aW9ucztcclxuICAgIGNvbnN0IHsgYXJndW1lbnRTZWxlY3RvckZ1bmN0aW9ucyB9ID0gcnVudGltZUluZm87XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGFyZ3VtZW50cyBmcm9tIHRoZSBhcHAgc3RhdGUgdXNpbmcgdGhlIHNlbGVjdG9yc1xyXG4gICAgcmVzdWx0cy5wdXNoKC4uLmFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMubWFwKGFyZ0ZuID0+IGFyZ0ZuKHN0YXRlKSkpO1xyXG5cclxuICAgIC8vIGlmIHRoZSBsYW1iZGEgdHJpZXMgdG8gYWNjZXNzIGEgc29tZXRoaW5nIG9uIHRoZVxyXG4gICAgLy8gc3RhdGUgdGhhdCBkb2Vzbid0IGV4aXN0LCBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxyXG4gICAgLy8gc2luY2UgdGhpcyBpcyBxdWl0ZSB1c3VhbCBiZWhhdmlvdXIsIHdlIHNpbXBseSByZXR1cm4gdW5kZWZpbmVkIGlmIHNvLlxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIG1lbW9pemVkRm4oLi4ucmVzdWx0cyk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgc3VwcHJlc3NFcnJvcnMpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBleDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IHNlbGVjdEZyb21BcHBTdGF0ZTtcclxuXHJcbiAgcmV0dXJuIG1lbW9pemVkRm47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldHVwU2VsZWN0b3JNZXRhZGF0YTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxyXG4gIG1lbW9pemVkRm46IFQsXHJcbiAgb3JpZ2luYWxGbjogVCxcclxuICBjcmVhdGlvbk1ldGFkYXRhOiBDcmVhdGlvbk1ldGFkYXRhIHwgdW5kZWZpbmVkXHJcbikge1xyXG4gIGNvbnN0IHNlbGVjdG9yTWV0YURhdGEgPSBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKG1lbW9pemVkRm4pO1xyXG4gIHNlbGVjdG9yTWV0YURhdGEub3JpZ2luYWxGbiA9IG9yaWdpbmFsRm47XHJcbiAgbGV0IGdldEV4cGxpY2l0U2VsZWN0b3JPcHRpb25zID0gKCkgPT4gKHt9KTtcclxuICBpZiAoY3JlYXRpb25NZXRhZGF0YSkge1xyXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5jb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEuY29udGFpbmVyQ2xhc3M7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdG9yTmFtZSA9IGNyZWF0aW9uTWV0YWRhdGEuc2VsZWN0b3JOYW1lO1xyXG4gICAgZ2V0RXhwbGljaXRTZWxlY3Rvck9wdGlvbnMgPVxyXG4gICAgICBjcmVhdGlvbk1ldGFkYXRhLmdldFNlbGVjdG9yT3B0aW9ucyB8fCBnZXRFeHBsaWNpdFNlbGVjdG9yT3B0aW9ucztcclxuICB9XHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YUNsb25lID0geyAuLi5zZWxlY3Rvck1ldGFEYXRhIH07XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5nZXRTZWxlY3Rvck9wdGlvbnMgPSAoKSA9PlxyXG4gICAgZ2V0Q3VzdG9tU2VsZWN0b3JPcHRpb25zKHNlbGVjdG9yTWV0YURhdGFDbG9uZSwgZ2V0RXhwbGljaXRTZWxlY3Rvck9wdGlvbnMoKSk7XHJcbiAgcmV0dXJuIHNlbGVjdG9yTWV0YURhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFJ1bnRpbWVTZWxlY3RvckluZm8oXHJcbiAgc2VsZWN0b3JNZXRhRGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxyXG4gIHNlbGVjdG9yczogYW55W10gfCB1bmRlZmluZWQgPSBbXVxyXG4pOiBSdW50aW1lU2VsZWN0b3JJbmZvIHtcclxuICBjb25zdCBzZWxlY3Rvck9wdGlvbnMgPSBzZWxlY3Rvck1ldGFEYXRhLmdldFNlbGVjdG9yT3B0aW9ucygpO1xyXG4gIGNvbnN0IHNlbGVjdG9yc1RvQXBwbHkgPSBnZXRTZWxlY3RvcnNUb0FwcGx5KHNlbGVjdG9yTWV0YURhdGEsIHNlbGVjdG9ycyk7XHJcbiAgY29uc3QgYXJndW1lbnRTZWxlY3RvckZ1bmN0aW9ucyA9IHNlbGVjdG9yc1RvQXBwbHkubWFwKHNlbGVjdG9yID0+IGdldFNlbGVjdG9yRm4oc2VsZWN0b3IpKTtcclxuICByZXR1cm4ge1xyXG4gICAgc2VsZWN0b3JPcHRpb25zLFxyXG4gICAgYXJndW1lbnRTZWxlY3RvckZ1bmN0aW9uc1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1c3RvbVNlbGVjdG9yT3B0aW9ucyhcclxuICBzZWxlY3Rvck1ldGFEYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwsXHJcbiAgZXhwbGljaXRPcHRpb25zOiBTaGFyZWRTZWxlY3Rvck9wdGlvbnNcclxuKTogU2hhcmVkU2VsZWN0b3JPcHRpb25zIHtcclxuICBjb25zdCBzZWxlY3Rvck9wdGlvbnM6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyA9IHtcclxuICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucy5nZXQoKSxcclxuICAgIC4uLihzZWxlY3Rvck9wdGlvbnNNZXRhQWNjZXNzb3IuZ2V0T3B0aW9ucyhzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzKSB8fCB7fSksXHJcbiAgICAuLi4oc2VsZWN0b3JPcHRpb25zTWV0YUFjY2Vzc29yLmdldE9wdGlvbnMoc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuKSB8fCB7fSksXHJcbiAgICAuLi4oc2VsZWN0b3JNZXRhRGF0YS5nZXRTZWxlY3Rvck9wdGlvbnMoKSB8fCB7fSksXHJcbiAgICAuLi5leHBsaWNpdE9wdGlvbnNcclxuICB9O1xyXG5cclxuICByZXR1cm4gc2VsZWN0b3JPcHRpb25zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZWxlY3RvcnNUb0FwcGx5KFxyXG4gIHNlbGVjdG9yTWV0YURhdGE6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCxcclxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkID0gW11cclxuKSB7XHJcbiAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG4gIGNvbnN0IGNhbkluamVjdENvbnRhaW5lclN0YXRlID1cclxuICAgIHNlbGVjdG9ycy5sZW5ndGggPT09IDAgfHwgc2VsZWN0b3JNZXRhRGF0YS5nZXRTZWxlY3Rvck9wdGlvbnMoKS5pbmplY3RDb250YWluZXJTdGF0ZTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IHNlbGVjdG9yTWV0YURhdGEuY29udGFpbmVyQ2xhc3M7XHJcbiAgaWYgKGNvbnRhaW5lckNsYXNzICYmIGNhbkluamVjdENvbnRhaW5lclN0YXRlKSB7XHJcbiAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0U3RvcmVNZXRhZGF0YShjb250YWluZXJDbGFzcyk7XHJcbiAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKC4uLnNlbGVjdG9ycyk7XHJcbiAgfVxyXG4gIHJldHVybiBzZWxlY3RvcnNUb0FwcGx5O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiJdfQ==